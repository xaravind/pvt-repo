Here’s the updated Markdown file with an **Agenda** section added at the top:

---

# 🚀 Full Project Setup Guide (GitHub → Docker → EC2 → EKS)

---

## 📝 Agenda

This guide walks you through the complete process of:

* ✅ Creating a private GitHub repository and pushing code with a Dockerfile
* ✅ Setting up an AWS EC2 instance
* ✅ Installing Docker, building images, and pushing them to Docker Hub
* ✅ Assigning IAM roles and preparing EC2 for EKS operations
* ✅ Installing and configuring EKS and deploying a containerized app
* ✅ Understanding rolling updates and cleaning up resources

---

## ✅ First Stage: GitHub Setup

1. Login to your GitHub account.
2. Create a **private repository**.
3. Go to the top right of your profile → **Settings** → **Developer Settings** → **Personal Access Tokens (PAT)**:

   * Select **Tokens (Classic)** → Click **Generate new token** → Choose **Generate new classic token**.
   * Set an expiry based on your choice and **grant only repo access**.
   * Scroll down and click on **Generate token**.
4. **Copy the token** and save it somewhere safe.
   **Note:** Never ever share your credentials or tokens with anyone.
5. Go to your private repository and **copy the Git URL**.
6. Open your **VS Code or local terminal** and **clone the repo using the token**.
7. Copy your project code into the **cloned Git folder**.
8. Write a `Dockerfile` in your project, save it, and **push the code**.
9. Open GitHub in your browser and check the files. You should see everything updated.

> ✅ We have now created a GitHub repo, generated a PAT key, cloned the repo locally, added code, created a Dockerfile, and pushed files to GitHub.

---

## ✅ Second Stage: Launch EC2 in AWS

1. Login to your **AWS account**.
2. Go to **EC2**, click **Instances**, and then click **Launch Instance**.
3. Provide a name and **create a new key pair**.
   Keep all other settings as **default**.
   This VM will be used to build images, create EKS clusters, and communicate with the cluster.
4. Choose **Amazon Linux AMI** (which is based on RHEL) and click **Launch instance**.
5. Copy the **public IP** and connect using **PuTTY or MobaXterm** (your choice).
6. Switch to root user and **update the server**:

   ```bash
   sudo su -
   yum update -y
   ```

> ✅ In this stage, we created an EC2 instance, generated a `.pem` key, launched the instance with default settings, connected to it, and updated the server.

---

## ✅ Third Stage: Docker Setup & Push Image

1. Install Git and Docker, then start Docker:

   ```bash
   yum install -y git docker
   systemctl start docker
   ```
2. Clone the **private repo** using your GitHub username and the **PAT key** as password.
3. Switch to the project directory and **build the Docker image**.
4. Check the image and run the container:

   ```bash
   docker ps
   docker run -dt --name jscode -p 80:80 jscode:1.0
   ```

   > ✅ Our Docker image is just **56.2MB** as we used the Alpine image (lightweight).
5. Go inside the container and **manually update `index.html`** to simulate changes (v1 → v2).
   This helps in debugging or modifying running containers during emergencies.
6. To access the app using `<public-ip>:80`, **modify EC2 security groups** and add **port 80** in inbound rules.
7. Exit the container and **create a new image** from the running container.
8. Login to **Docker Hub**, create a **private repo** to store images.
9. Tag images for pushing:

   ```bash
   docker tag jscode:1.0 xaravind/jscode:v1
   docker tag jscode:2.0 xaravind/jscode:v2
   ```
10. Login to Docker using your credentials.
    This will create `/root/.docker/config.json` which stores credentials.
    We will use this file to pull images in Kubernetes.
11. Push the tagged images to Docker Hub:

    ```bash
    docker push xaravind/jscode:v1
    docker push xaravind/jscode:v2
    ```
12. Open Docker Hub in browser and **verify images are uploaded**.

> ✅ In this stage, we installed packages, cloned the repo, built Docker images, ran and modified containers, and pushed final images to Docker Hub.

---

## ✅ Fourth Stage: EKS Setup with IAM Role

1. Go to AWS Console → Search for **IAM**.
2. Click **Roles** → **Create role**.
3. Select **Trusted entity type: AWS Service** and use case as **EC2**, then click **Next**.
4. Choose **AdministratorAccess** policy (has full EC2 + EKS permissions), then click **Next**.
5. Name the role and click **Create Role**.
6. Go to **EC2 Instances**, select your instance → **Actions** → **Security** → **Modify IAM role**.
7. Attach the newly created **IAM role** to the instance.

> ✅ Now your EC2 instance can control AWS services via AWS CLI.

8. AWS CLI comes pre-installed in Amazon Linux.
   For other OS, you’ll need to install it manually.

9. Check AWS access:

   ```bash
   aws s3 mb s3://test-k8s.js
   aws s3 ls
   ```

10. Create an `eks.yml` file locally and push it to GitHub.

    > We are using **spot instances** for cost-saving (\~90% discount), but they may be terminated with short notice.

11. Pull the updated code into the EC2 instance.

12. Install `eksctl`:
    Follow instructions from [https://eksctl.io/installation](https://eksctl.io/installation)

13. Use the `eks.yml` file to **create an EKS cluster**.

    > This takes time and will create required AWS services like nodes, VPCs, SGs, ASG, etc.

14. Install `kubectl` to interact with the cluster.

15. Test kubectl:

```bash
kubectl get nodes
```

16. Create a base64 secret from Docker credentials to use in Kubernetes secrets:

```bash
cat ~/.docker/config.json | base64 -w 0
```

17. Create a manifest file locally, push it to GitHub, and pull it on the EC2 instance.

18. Create a namespace and apply the manifest file:

```bash
kubectl create namespace frontend
kubectl apply -f manifest.yaml -n frontend
```

19. Check pods and services.
    Kubernetes will create a **LoadBalancer service** with a random **NodePort (30000–32767)**.

20. To access the app, **add inbound rule for NodePort range (30000–32767)** in the security group.

21. Go to EC2 → Nodes → Security Group → Edit Inbound Rules → Add port range.

22. Access the application via LoadBalancer or NodePort.

> ✅ Observe how Kubernetes rolls out the new version of your app without downtime – this is called a **rolling update**.

---

## ✅ Final Cleanup

* Once done, **clean up your project** to avoid charges:

  * Delete EKS cluster
  * Remove EC2 instance
  * Delete S3 buckets and Docker images if not needed

---

Let me know if you'd like this exported as a file or converted to a designed PDF!
